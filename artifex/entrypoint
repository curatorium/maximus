#!/bin/bash
# Copyright (c) 2026 Mihai Stancu (https://github.com/curatorium)

# @name artifex
# @type command
#
# @desc The entrypoint for Artifex containers handling task execution.
# @desc Takes tasks from /tasks/inbox/*.md (chanels) or /tasks/*/inbox/*.md (threads).
function artifex:main() {
	# Do nothing if sourced
	[[ "${BASH_SOURCE[0]}" != "$0" ]] && return;

	set -Eeuo pipefail;

	# Handle subcommands like `artifex attach`.
	local cmd="${1:-}"; shift || true;
	if [[ -n "$cmd" ]]; then
		"artifex:$cmd" "$@";
		return;
	fi

	mkdir -p /app/.claude/tasks/{inbox,working,outbox,done};

	artifex::recover;

	while true; do
		# Find oldest task -- process FIFO
		local task; task=$(find /app/.claude/tasks -path '*/inbox/*.md' -type f | sort | head -n 1);

		# No tasks -- waiting
		[[ -z "$task" ]] && sleep 0.1s && continue;

		artifex::task "$task";
	done
}

# @name artifex attach
# @type subcommand
#
# @desc Allows Artifex users to attach & continue a claude conversation session.
function artifex:attach() {
	local continue=; [[ -f ~/.claude/projects/-app/sessions-index.json ]] && continue="--continue";

	stty susp undef 2>/dev/null;
	claude ${continue:+$continue} --dangerously-skip-permissions "$@";
}

# @name artifex::recover
# @type internal
#
# @desc Recovers interrupted tasks on startup.
# @desc Moves working/*.md back to inbox/ with a resume instruction appended.
function artifex::recover() {
	local task;
	while IFS= read -r task; do
		local base; base="$(dirname "$(dirname "$task")")";
		local name; name="$(basename "$task")";

		mkdir -p "$base/inbox";

		printf '\n\n---\n\nYou were previously working on the above task but were interrupted. Review the local changes and resume work.\n' >> "$task";
		mv "$task" "$base/inbox/";
		echo "~~~ Recovered interrupted task: $name";
	done < <(find /app/.claude/tasks -path '*/working/*.md' -type f 2>/dev/null)
}

# @name artifex::task
# @type internal
#
# @desc Task flow inbox/$task -> working/$task -> done/$task
# @desc                          outbox/$reply -> sent/$reply
function artifex::task() {
	local started=$SECONDS;
	local task="${1:-}";

	local base; base="$(dirname "$(dirname "$task")")";
	mkdir -p "$base/working" "$base/outbox" "$base/done";

	local name; name="$(basename "$task")";

	# Claim task -- avoids conflicts
	mv "$task" "$base/working/";
	echo ">>> Working on $name";

	local tmp; tmp="$(mktemp)";
	# shellcheck disable=2064
	trap "rm -f $tmp" EXIT;

	local rc=0; artifex::retry 2 artifex::run "$base/working/$name" "$tmp" || rc=$?;

	# Send response -- extract .result from JSON, or forward raw error text
	local result; result="$(jq -Rsr 'try (fromjson | .result // empty) catch .' "$tmp")";
	echo "${result:-Done!}" > "$base/outbox/$name";

	(( rc == 0 )) &&
		echo "<<< Finished $name in $((SECONDS - started))s" ||
		echo "!!! Failed $name after $((SECONDS - started))s (rc=$rc)";

	mv "$base/working/$name" "$base/done/";
}

# @name artifex::retry
# @type internal
function artifex::retry() {
	local attempts=$1; shift;
	for ((attempt = 1; attempt <= attempts; attempt++)); do
		local rc=0; "$@" || rc=$?;
		case $rc in
			0)  return 0;;   # Success
			75) ;;           # Retryable -- continue
			*)  return $rc;; # Fatal -- stop without retry
		esac
	done
	return 75;
}

# @name artifex::run
# @type internal
function artifex::run() {
	local input="$1"; shift;
	local out="$1";   shift;

	local name; name="$(basename "$input")";

	local taskdir; taskdir="$(dirname "$(dirname "$input")")";

	local prompt='
		You are running inside a Docker container, receiving tasks asynchronously via Discord.

		# Environment
		- /app — the project root (mounted from host).

		# Communication
		Your exchange is asynchronous — mediated by a Discord bot. Each round-trip is a separate task. You CAN ask clarifying questions but batch them — be specific about what you need to proceed.
		The user cannot see your tool calls, file reads, or intermediate output. Your final text response is the ONLY thing relayed. Be concrete: what you found, what you changed (file paths, summaries), what you could not do and why.

		# Formatting (Discord)
		Messages are chunked at 2000 chars, splitting on \n---\n.
		- Use \n---\n between logical sections for clean chunk boundaries.
		- No markdown tables — use fenced code blocks with aligned columns instead.
		- No HTML tags.
	';
	ARTIFEX_PROMPT="${ARTIFEX_PROMPT:-$prompt}";

	local nudge="After completing this task, write a summary of what you did and what you found.";
	ARTIFEX_NUDGE="${ARTIFEX_NUDGE:-$nudge}";

	local continue=""; [[ -f ~/.claude/projects/-app/sessions-index.json ]] && continue="--continue";

	local args=(
		${continue:+$continue}
		--model "${ARTIFEX_MODEL:-opus}"
		--print --verbose --output-format stream-json
		--dangerously-skip-permissions
		--append-system-prompt "$ARTIFEX_PROMPT"
	);

	# Run Claude Code with task in STDIN, prefixed with result instruction
	# Stream processor writes intermediate text blocks to outbox for Scribe
	local rc=0;
	{ echo "$ARTIFEX_NUDGE"; echo; cat "$input"; } |
		claude "${args[@]}" 2>&1 |
		artifex::stream "$taskdir/outbox/$name" > "$out" ||
		rc=$?;

	# Auth token expired -- fatal
	if (( rc != 0 )) && grep -qi "auth\|unauthorized\|401\|api.key\|invalid.*key" "$out"; then
		return 2; # No retry
	fi

	# No previous session (first run) -- retry without --continue
	if (( rc != 0 )) && grep -qi "session.*not.found\|no.*conversation" "$out"; then
		return 75;
	fi

	# Unknown error
	if (( rc != 0 )); then
		sleep 5s;
		return 1;
	fi

	artifex::compact < "$out";

	return 0;
}

# @name compact
# @type internal
#
# @desc Automatically compacts when getting to 75% to context window size.
function artifex::compact() {
	local tokens; tokens="$(jq -r '[.usage.input_tokens, .usage.cache_creation_input_tokens, .usage.cache_read_input_tokens] | map(. // 0) | add')";
	(( tokens <= 750000 )) && return 0;

	echo "~~~ Context at ${tokens} tokens (>75%), compacting...";
	echo "/compact" | claude --continue --print --output-format json --dangerously-skip-permissions "$@" > /dev/null 2>&1 || true;
}

# @name artifex::stream
# @type internal
#
# @desc Processes stream-json output: writes assistant text blocks to outbox,
# @desc passes only the final summary line to stdout.
function artifex::stream() {
	local reply="$1";
	local last="";
	while IFS= read -r line; do
		[[ -z "$line" ]] && continue;
		last="$line";

		if ! jq -er 'select(.type == "assistant" and .message.type == "text")' <<<"$line" > /dev/null 2>&1; then
			continue;
		fi

		local text; text=$(jq -r '.message.content' <<<"$line" 2>/dev/null);
		[[ -n "$text" ]] && echo "$text" >> "$reply";
	done

	# Final line is the JSON summary — goes to stdout (captured in $out)
	echo "$last";
}

artifex:main "$@";
